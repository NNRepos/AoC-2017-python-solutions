import sys
import re
import operator as op
beginning="""\
.#.
..#
###"""
input="""\
../.. => .##/..#/##.
#./.. => ##./#../#..
##/.. => ###/#.#/..#
.#/#. => .../#../##.
##/#. => ###/#../###
##/## => .##/.##/#.#
.../.../... => #.##/#.##/###./..##
#../.../... => ##.#/..##/#.#./##.#
.#./.../... => ###./.#.#/.#../.###
##./.../... => ##.#/###./..../##..
#.#/.../... => ##.#/.###/.##./#.#.
###/.../... => #..#/.##./#.../.#.#
.#./#../... => .##./####/#..#/###.
##./#../... => ##../..#./#.##/..##
..#/#../... => #.##/.#.#/##../..##
#.#/#../... => #.../##../..#./.##.
.##/#../... => #.#./.#.#/#.##/#..#
###/#../... => .#../.#../...#/##..
.../.#./... => ..#./..#./##../.#.#
#../.#./... => ##../####/##../.###
.#./.#./... => ..../#..#/#.#./....
##./.#./... => ..##/####/..../##..
#.#/.#./... => #.##/##../#.../..#.
###/.#./... => ..../..../####/#..#
.#./##./... => ..../####/##.#/....
##./##./... => ####/#.../.###/#.##
..#/##./... => .#.#/.#../###./.#..
#.#/##./... => .#.#/###./..../..##
.##/##./... => #.../.#.#/.#.#/...#
###/##./... => #.##/.#../.#../#...
.../#.#/... => ###./..#./.#../..##
#../#.#/... => #..#/#.##/.#../...#
.#./#.#/... => ####/..#./..../..#.
##./#.#/... => #.#./..../.###/..#.
#.#/#.#/... => #..#/.#../#.#./.###
###/#.#/... => .##./#..#/.#.#/..#.
.../###/... => .#../#..#/...#/.##.
#../###/... => .##./##../###./##.#
.#./###/... => ...#/..##/###./...#
##./###/... => .#.#/##.#/.###/.#..
#.#/###/... => #.#./##../#.#./..#.
###/###/... => .#.#/####/###./####
..#/.../#.. => .#../#.##/..../..#.
#.#/.../#.. => ..../.#.#/##../#..#
.##/.../#.. => #.##/.#.#/#..#/.#.#
###/.../#.. => #..#/.#.#/#.#./##.#
.##/#../#.. => ##../##.#/##.#/#..#
###/#../#.. => ..../#..#/###./#.##
..#/.#./#.. => ..../.#../..../.##.
#.#/.#./#.. => #..#/#.##/.###/....
.##/.#./#.. => ###./..../##.#/#.#.
###/.#./#.. => #.../###./.#.#/..#.
.##/##./#.. => ..../.#../..#./#.#.
###/##./#.. => ...#/.###/###./####
#../..#/#.. => ..../.##./..##/..##
.#./..#/#.. => .#.#/#.../#..#/###.
##./..#/#.. => #.#./.##./.##./....
#.#/..#/#.. => #..#/..##/##.#/##..
.##/..#/#.. => ..#./#.../.##./##.#
###/..#/#.. => ##../.##./####/.##.
#../#.#/#.. => ###./#.#./###./.#.#
.#./#.#/#.. => .##./#.#./#..#/..#.
##./#.#/#.. => .#.#/#.#./#.../##.#
..#/#.#/#.. => .##./##.#/.#.#/.#.#
#.#/#.#/#.. => .#../.##./###./#...
.##/#.#/#.. => ####/##../.##./##.#
###/#.#/#.. => ###./.##./##.#/#...
#../.##/#.. => ...#/#.#./..##/####
.#./.##/#.. => #.../##.#/.##./###.
##./.##/#.. => ##.#/.#.#/..../#.#.
#.#/.##/#.. => ..../#.../.#.#/..#.
.##/.##/#.. => ##../..../..#./#.##
###/.##/#.. => ..#./...#/#..#/...#
#../###/#.. => ..../.#../#.../###.
.#./###/#.. => ..../#.#./.#.#/...#
##./###/#.. => ###./###./..#./.###
..#/###/#.. => #.##/..#./..##/#...
#.#/###/#.. => ##.#/.#.#/##../#..#
.##/###/#.. => ###./..##/#.../....
###/###/#.. => .###/###./#.../..#.
.#./#.#/.#. => ..##/##.#/.##./####
##./#.#/.#. => ..../.#.#/#.../###.
#.#/#.#/.#. => ##.#/###./..#./.#..
###/#.#/.#. => .###/##../.###/....
.#./###/.#. => ####/.###/.###/....
##./###/.#. => #.#./#..#/#..#/###.
#.#/###/.#. => #.#./.#.#/#.##/####
###/###/.#. => #.#./.###/..#./#.#.
#.#/..#/##. => ###./.#.#/##../##..
###/..#/##. => #.../.###/#.../..#.
.##/#.#/##. => #..#/.#.#/...#/.#..
###/#.#/##. => ...#/###./..##/.#.#
#.#/.##/##. => ###./...#/..../#...
###/.##/##. => ...#/#.../#.##/##..
.##/###/##. => .###/.###/..#./#...
###/###/##. => #.../##../##.#/.###
#.#/.../#.# => ##../#.##/..#./.###
###/.../#.# => #.#./.##./.##./#..#
###/#../#.# => #.../##../####/..##
#.#/.#./#.# => #.../.#../#.../..##
###/.#./#.# => #..#/###./####/#...
###/##./#.# => ##../..##/#.#./##..
#.#/#.#/#.# => .#../.#.#/#.#./.#.#
###/#.#/#.# => ..##/####/####/.###
#.#/###/#.# => .###/##../#..#/..#.
###/###/#.# => ##../#.../##.#/##..
###/#.#/### => ###./...#/####/..#.
###/###/### => .##./##../..../..#."""

try:
  #"globals"
  curr=beginning.split('\n')
  rules=input.split('\n')
  rules = [rule.split(' => ') for rule in rules]
  iterations=5
  #functions
  def rotate(block):
    ret=[]
    ret+=[''.join(i) for i in zip(*block)]
    return ret
  def mirror(block):
    ret=[i[::-1] for i in block]
    return ret
  def matchRule(rule,block):
    target=rule[0]
    # print block
    # print "matching\n",block,"\nwith\n",target
    for rot in range(4):
      # print "rot",rot
      if (block==target):
        return rule[1]
      block='/'.join(mirror(block.split('/')))
      if (block==target):
        return rule[1]
      block='/'.join(rotate(block.split('/')))
  #main
  print curr
  print len(curr)
  for counter in range(iterations):
    size=len(curr)
    blocks=[];
    if (not size%2):
      for i in range(size/2):
        for j in range(size/2): # for each block
          block=curr[i*2][j*2]+curr[i*2][j*2+1]+'/'+\
                curr[i*2+1][j*2]+curr[i*2+1][j*2+1]
          replacement=None;
          for rule in rules:
            replacement=matchRule(rule,block)
            if (replacement):
              break;
          if (not replacement):
            raise Exception("no matching rule")
          blocks.append(replacement)
      # print "b4",blocks
      newsize=size*3/2
      curr=['' for i in range(newsize)] #empty 2d array
      blocks = [block.split('/') for block in blocks]
      # print "b",blocks
      for i in range(newsize/3): #for every 3 rows
        for j in range(newsize/3): #for every 3 columns
          for k in range(3): # for every 1x3 row
            curr[i*3+k]+=str(blocks[i*size/2+j][k]) #add to every row in curr, j times, the kth row in the block
        # print curr
    elif (not size%3):
      for i in range(size/3):
        for j in range(size/3):
          block=curr[i*3][j*3]+curr[i*3][j*3+1]+curr[i*3][j*3+2]+'/'+\
                curr[i*3+1][j*3]+curr[i*3+1][j*3+1]+curr[i*3+1][j*3+2]+'/'+\
                curr[i*3+2][j*3]+curr[i*3+2][j*3+1]+curr[i*3+2][j*3+2]
          replacement=None;
          for rule in rules:
            replacement=matchRule(rule,block)
            if (replacement):
              break;
          if (not replacement):
            raise Exception("no matching rule")
          blocks.append(replacement)
      newsize=size*4/3
      curr=['' for i in range(newsize)] #empty 2d array
      blocks = [block.split('/') for block in blocks]
      for i in range(newsize/4): #for every 4 rows
        for j in range(newsize/4): #for every 4 columns
          for k in range(4): # for every 1x4 row
            curr[i*4+k]+=str(blocks[i*size/3+j][k]) #add to every row in curr, j times, the kth row in the block
    else:
      raise Exception("size error")
    print curr
    print newsize
  curr='/'.join(curr)
  print "final:\n",curr
  hash=curr.count('#')
  print hash,"pixels are on"
except Exception as e:
  print str(e),sys.exc_info()[2].tb_lineno
finally:
  raw_input()